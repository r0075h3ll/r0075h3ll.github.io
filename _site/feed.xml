<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-03-14T06:49:03+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hardik Nanda</title><subtitle></subtitle><author><name></name></author><entry><title type="html">Hacking Electron Applications - 0x101</title><link href="http://localhost:4000/Hacking-Electron-Applications-101/" rel="alternate" type="text/html" title="Hacking Electron Applications - 0x101" /><published>2022-04-03T00:00:00+05:30</published><updated>2022-04-03T00:00:00+05:30</updated><id>http://localhost:4000/Hacking-Electron-Applications-101</id><content type="html" xml:base="http://localhost:4000/Hacking-Electron-Applications-101/"><![CDATA[<p>This post can be considered as a 101 guide to few concepts, which are</p>
<ul>
  <li>How browsers work</li>
  <li>What is electron</li>
  <li>Reverse engineering electron applications</li>
  <li>Commonly exploited misconfigurations</li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>Browser, that’s something you are using right now to read this article, but how is this working, how does some symbolic stuff come together to form something that looks cool(or boring maybe). You see, browser is something, in an abstract way, that fetches and displays the content you requested, and for doing that it comes with following components:</p>
<ul>
  <li>Rendering engine : Figures out how to display the requested content</li>
  <li>JavaScript engine : Executes JS code</li>
  <li>UI &amp; Its backend</li>
  <li>Networking : Performing network related operations to fetch and send data</li>
  <li>Data Storage : Storing cookies</li>
</ul>

<h4 id="types-of-process">Types of process</h4>

<p>Talking about modern web browsers, they primarily, have got three types of process:</p>
<ul>
  <li>Main/browser process</li>
  <li>Renderer process</li>
  <li>Plugin process</li>
</ul>

<p>The main process mainly handles functions such as window creation and management, storage related stuff(such as cookie storage), networking, etc. Renderer processes looks over the frontend part, like parsing HTML and CSS, decoding images, etc. and the Plugin process literally contains the plug-ins in it.</p>

<h4 id="multi-process-architecture">Multi-process architecture</h4>

<p>At one time, a single evil web app was enough to crash a browser, because all of it was managed by a single process and thus making it a perfect target for attackers, as crashing a single tab successfully would make other things go ham as well. Presently, each tab on your browser is managed by separate renderer process, so even if a web page acts suspicious and hangs up on you, you can still operate on the other tabs. This comes with an advantage and a disadvantage as well.</p>

<p>Each process in a computer has got its own private memory space and resources, which isn’t shared. This makes the program, which is getting executed, secure from any outer interventions, this is also called Sandboxing. However, this also increases the overall memory consumption, because for each tab a separate renderer process is being created. This procedure of process creation/management is mainly followed by Chrome and Chromium.</p>

<h3 id="electron">Electron</h3>

<blockquote>
  <p>Electron is a runtime framework that facilitates cross-platform desktop application development by using HTML, CSS and JavaScript. It uses <strong>Node.js</strong> for backend and <strong>libchromiumcontent</strong> from Chromium for rendering(frontend).</p>
</blockquote>

<p>Creating desktop application has its own complications. Set of tools, libraries, languages, frameworks, etc. completely change when you hop onto some other operating system, thus making cross-platform desktop application development a troublesome task.</p>

<p>The reason I discussed about browsers, particularly about Chromium, before jumping into Electron, is because Electron uses some browser(Chromium) components to do its work and therefore the multi-process architecture resembles. There are two types of processes that run in an Electron app:</p>
<ul>
  <li>Main process</li>
  <li>Renderer process</li>
</ul>

<p>Each app can have only one Main process but multiple Renderer processes can be spawned by the main process. Main process is a privileged process because it runs in Node.js environment and therefore it has access to Node.js APIs. Renderer, on the other hand, is the not-so privileged process, as the name suggests, it handles the rendering part.</p>

<p>How does an Electron app use system functionalities(like reading/writing into files, etc.), you might ask. We’ve got preload scripts for that.</p>

<p>Preload scripts contain code that runs in renderer <a href="https://blog.kevinchisholm.com/javascript/context-object-literals/">context</a> before the web app’s code. These scripts have higher privileges since they’ve access to Node.js APIs.</p>

<h3 id="reverse-engineering-electron-applications">Reverse engineering electron applications</h3>

<p>Electron applications come packed in <strong>asar</strong> format, which is basically a simple TAR like format. In order to get the source code of an application, you’ll have to extract a particular asar file. The process can be broken down into following steps:</p>

<ul>
  <li>Run any app that uses Electron, I’ve taken Discord for this example, and then do
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps x | grep -i 'discord.*path'
</code></pre></div>    </div>
  </li>
  <li>Try looking out for a string that looks like this <em>–app-path=/opt/discord/resources/app.asar</em></li>
  <li>Go to that directory and extract the content
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> <span class="nt">-g</span> asar
asar extract app.asar discord-app 
<span class="nb">cd </span>discord-app
</code></pre></div>    </div>
  </li>
</ul>

<p>Reference : <a href="https://dev.to/essentialrandom/adventures-in-hacking-electron-apps-3bbm">Adventures in Hacking Electron Apps</a></p>

<h3 id="misconfigurations">Misconfigurations</h3>

<p>The first step towards finding a vulnerability(after extracting the .asar file) is to find a place to search for, basically finding an entry point is your next task. Mostly, you will find package.json which acts like a configuration file for the application. Below is a snippet of <a href="https://github.com/MrH4r1/Electro-XSS">package.json</a> to give you an about what kind of information it contains:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"electro-xss"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1.0.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"An Electron application that may be exploited for XSS and RCE."</span><span class="p">,</span><span class="w">
  </span><span class="nl">"main"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.js"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"electro-xss"</span><span class="p">:</span><span class="w"> </span><span class="s2">"electron ."</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"author"</span><span class="p">:</span><span class="w"> </span><span class="s2">"MrH4r1"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"license"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ISC"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"electron"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^17.0.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"jquery"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^3.6.0"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>The <strong>main</strong> field in above snippet, points to the start-up script of the application(which is index.js in this case), this <strong>index.js</strong> is our entry point in this scenario. After getting to the entry point, you can now look out for certain misconfigurations that carry huge impact. Electron is provided with two significant features, that are commonly exploited:</p>

<ul>
  <li>nodeIntegration : allows application to access Node.js APIs to work with system components</li>
  <li>contextIsolation : separates/isolates Electron’s internal logic and preload script from the actual application code</li>
</ul>

<h4 id="node-integration">Node Integration</h4>

<p>This basically allows the renderer process to use Node.js APIs to use the wide range of system functionalities it offers, like arbitrary file read/write, creating child processes, execution of binary files, performing network related operations. Enabling this will give the client side scripts access to system wide functionalities.</p>

<p>Vulnerable code will look something like this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//index.js</span>
<span class="kd">const</span> <span class="nx">MainWindow</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BrowserWindow</span><span class="p">({</span>
  <span class="na">webPreferences</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">nodeIntegration</span><span class="p">:</span> <span class="kc">true</span>
        <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p><em>BrowserWindow</em> is an object that is used to control window functions such as minimization, maximization, window creation, etc.</p>

<p>Let’s consider a scenario where an app is vulnerable to XSS. Because it is vulnerable to XSS, the attacker can now inject arbitrary JS code with <a href="https://nodejs.org/en/knowledge/getting-started/what-is-require/">require()</a> function.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;img src=x onerror=alert(require('child_process').exec('xcalc'))&gt; //a simple payload to pop a calculator
</code></pre></div></div>

<h4 id="context-isolation">Context Isolation</h4>

<p>Context Isolation is another attribute in Electron that runs preload scripts and Electron’s internal logic in a separate context. Preload scripts have access to Node.js modules and therefore the misconfiguration will lead to app(running in renderer process) getting access to APIs accessible by preload script(s). Below is the snippet that has got contextIsolation set to <em>false</em>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//index.js</span>
<span class="kd">const</span> <span class="nx">MainWindow</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BrowserWindow</span><span class="p">({</span>
  <span class="na">webPreferences</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">nodeIntegration</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="na">contextIsolation</span><span class="p">:</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>
<p>Attackers can use this misconfig to completely change the application functionality.</p>

<h3 id="conclusion">Conclusion</h3>

<p>This was just a “little” glimpse of the world of desktop applications made with Electron. Electron has already implemented a couple of security measures, for example nodeIntegration is set to <em>false</em> and contextIsolation is set to <em>true</em> by default, thus preventing plain attack vectors beforehand. Nevertheless, the implemented defenses are not foolproof so far, researchers are still finding new attack vectors every now-and-then.</p>

<p>If you want to go futher with the topic, you can check out <a href="https://blog.doyensec.com/">Doyensec’s Blog</a>, it has got a lot of awesome articles related to Electron security, you can give them a read.</p>

<p>That’s all for this post, meet you in another one.</p>]]></content><author><name></name></author><category term="Web" /><category term="electron" /><category term="javascript" /><summary type="html"><![CDATA[This post can be considered as a 101 guide to few concepts, which are How browsers work What is electron Reverse engineering electron applications Commonly exploited misconfigurations Introduction Browser, that’s something you are using right now to read this article, but how is this working, how does some symbolic stuff come together to form something that looks cool(or boring maybe). You see, browser is something, in an abstract way, that fetches and displays the content you requested, and for doing that it comes with following components: Rendering engine : Figures out how to display the requested content JavaScript engine : Executes JS code UI &amp; Its backend Networking : Performing network related operations to fetch and send data Data Storage : Storing cookies Types of process Talking about modern web browsers, they primarily, have got three types of process: Main/browser process Renderer process Plugin process The main process mainly handles functions such as window creation and management, storage related stuff(such as cookie storage), networking, etc. Renderer processes looks over the frontend part, like parsing HTML and CSS, decoding images, etc. and the Plugin process literally contains the plug-ins in it. Multi-process architecture At one time, a single evil web app was enough to crash a browser, because all of it was managed by a single process and thus making it a perfect target for attackers, as crashing a single tab successfully would make other things go ham as well. Presently, each tab on your browser is managed by separate renderer process, so even if a web page acts suspicious and hangs up on you, you can still operate on the other tabs. This comes with an advantage and a disadvantage as well.]]></summary></entry><entry><title type="html">Content Security Policy for Dummies</title><link href="http://localhost:4000/CSP-for-Dummies/" rel="alternate" type="text/html" title="Content Security Policy for Dummies" /><published>2022-03-20T00:00:00+05:30</published><updated>2022-03-20T00:00:00+05:30</updated><id>http://localhost:4000/CSP-for-Dummies</id><content type="html" xml:base="http://localhost:4000/CSP-for-Dummies/"><![CDATA[<p>Ah, I am writing this post after 2 years of writing my first one, procrastination never hit me like that before. Anyways, without wasting much of your time, let’s just get started with the topic. In this post, I’ll elaborate two things:</p>
<ol>
  <li>How CSP works</li>
  <li>Bypassing CSP</li>
</ol>

<h3 id="introduction">Introduction</h3>

<p>Content Security Policy is a browser security mechanism that can be used as a second line of defense against code injection attacks such as XSS, ClickJacking, etc. Content Security Policy works on whitelist based mechanism which means it maintains a list of sources from which the application is allowed to access/import resources like scripts, plugins, images, data, etc.</p>

<p>Web Applications can impose Content Security Policy by:</p>
<ul>
  <li>Issuing certain HTTP response headers
    <ul>
      <li>X-Content-Security-Policy</li>
      <li>Content-Security-Policy</li>
      <li>X-WebKit-CSP</li>
      <li>Content-Security-Policy-Report-Only</li>
    </ul>
  </li>
  <li>HTML Meta Tag
    <ul>
      <li><code class="language-plaintext highlighter-rouge">&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'"&gt;</code></li>
    </ul>
  </li>
</ul>

<h3 id="implementation">Implementation</h3>

<p>As I said, Content Security Policy can also be implemented by issuing response header(s) and thus understanding those headers will let us see what can go wrong in certain situations and how can attackers exploit that.</p>

<p>Content Security Policy does stuff by using directives, a directive is just a combination of resource type and attribute or it can be defined by mentioning the resource type and the attribute(s) (attributes indicate sources from where content can be loaded and/or executed of a particular resource type). If multiple directives have to be used at once, then a semicolon is used as delimiter. Following are some of the frequently used directives(with their attributes) in CSP:</p>
<ul>
  <li>default-src: ‘self’</li>
  <li>script-src: ‘unsafe-inline’</li>
  <li>object-src: ‘none’</li>
  <li>image-src: https:</li>
</ul>

<h4 id="explaination">Explaination</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Resource Type</th>
      <th style="text-align: center">Attribute</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">default-src</td>
      <td style="text-align: center">‘self’</td>
      <td style="text-align: left">‘default-src’ is used as a fallback option when the dev is too lazy to define sources for each resource type. ‘self’ indicates that the website can only load resource(s) from the same origin.</td>
    </tr>
    <tr>
      <td style="text-align: center">script-src</td>
      <td style="text-align: center">‘unsafe-inline’</td>
      <td style="text-align: left">‘script-src’ defines location from where JS code can loaded, ‘unsafe-inline’ imply that inline JS code can be loaded &amp; executed</td>
    </tr>
    <tr>
      <td style="text-align: center">object-src</td>
      <td style="text-align: center">‘none’</td>
      <td style="text-align: left">‘object-src’ defines sources from where plugins can be loaded, ‘none’ here clearly states that plugins are not allowed</td>
    </tr>
    <tr>
      <td style="text-align: center">image-src</td>
      <td style="text-align: center">https:</td>
      <td style="text-align: left">‘https:’ is a scheme and indicates that images should loaded from website that use “https:”</td>
    </tr>
  </tbody>
</table>

<p>You can find more directives <a href="https://content-security-policy.com/">here</a></p>

<h3 id="exploitation">Exploitation</h3>

<p>Till now, we saw some examples that gave us a basic idea about how directives in CSP come along to protect the application and/or users. It’s time we should jump onto the part where analysis of directives will lead to exploration of possible vulnerablities.</p>

<p>Developers find it complex to configure CSP and that’s what causing most of the screw ups out there. Following are some of the places where the miss outs happen, thus paving a way for code injection attacks:</p>
<ul>
  <li>Using unsafe attribute(s) and/or directives</li>
  <li>Nonce</li>
  <li>JSONP attack</li>
</ul>

<h3 id="using-unsafe-attributes-andor-directives">Using unsafe attributes and/or directives</h3>

<p>So, directives are the building blocks of CSP and getting them wrong will lead to take down of the whole wall of security. In CSP, there are certains attributes that’ve already been flagged <strong>unsafe</strong> because assigning them to directives simply makes the application as vulnerable as it was without CSP. Some of these attributes and directives are:</p>
<ul>
  <li>unsafe-inline</li>
  <li>unsafe-eval</li>
  <li>data:</li>
  <li>base-uri</li>
</ul>

<p><strong>unsafe-inline</strong> - It has been flagged unsafe cause it grants the application to execute inline scripts, which basically means that any JS code injected by the attacker would be executed by the application and this defeats the whole purpose of having a CSP in the first place.</p>

<p><strong>unsafe-eval</strong> - There are certain functions &amp; constructors in JavaScript that are better of not being used; <strong>eval()</strong> is one of them. It can perform dynamic instructions by using input recieved from any user. Using <strong>unsafe-eval</strong> allows the application to use dynamic code evaluation which is not considered a good practice.</p>

<p><strong>data:</strong> - This directive is used to grant developers permission to import data from base64 strings. Using this directive in combination with <strong>script-src ‘unsafe-eval’</strong> can lead to execution of attacker’s injected code.</p>

<p>An exploitable situation will look something like:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>response header: Content-Security-Policy: script-src 'unsafe-eval' data: 'self'
bypass: &lt;script src="data:;base64,WFNTCg=="&gt;&lt;/script&gt;
</code></pre></div></div>

<p><strong>base-uri</strong> - This directive sets the base URL for the relative URLs that exist in a document. Absence of this directive will let the attacker set/inject the base URL ultimately granting access to tamper with files that are being served on the application.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
	<span class="nt">&lt;base</span> <span class="na">href=</span><span class="s">"http://www.google.com"</span> <span class="na">target=</span><span class="s">"_blank"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"/hello.js"</span><span class="nt">&gt;&lt;/script&gt;</span> <span class="c">&lt;!-- this sets location to http://www.google.com/hello.js as the base URL is set to http://www.google.com !&gt;
</span></code></pre></div></div>

<h3 id="nonce">Nonce</h3>

<p>Nonce is just a long string of random characters. Inline scripts are by default blocked in a page by CSP, but sometimes it is a necessity to use inline script(s) and using Nonce allows developers to do so in a secure way. In order to inject an inline script, <strong>nonce</strong> attribute must be set in the script element.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">nonce=</span><span class="s">"r4nd0m455Ch4r5"</span><span class="nt">&gt;</span>
	<span class="kd">var</span> <span class="nx">blah</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">DND</span><span class="dl">"</span><span class="p">;</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Following are some instances of misconfigs that an attacker can exploit:</p>
<ul>
  <li>Same Nonce being used for multiple requests - Same Nonce can be used for multiple request, thus allowing attacker to inject inline scripts</li>
  <li>Predictable Nonce values - Values are not random, attacker can predict another valid Nonce and use that to inject inline scripts</li>
  <li>Outputting user/attacker controllable values inside Nonce protected script</li>
</ul>

<p>To understand the third bullet point, let’s consider a scenario where we’ve got an URL and a Nonce protected inline script:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://www.google.com/hey.php?id=1

&lt;script nonce="r4nd0m455Ch4r5"&gt;
	var id = #URL.id# //assigns the value of id parameter to this variable
&lt;script&gt;
</code></pre></div></div>
<p><strong>id</strong> parameter in the given URL is user controllable, and to achieve code injection the attacker only needs to replace the parameter’s value with a valid payload.</p>

<h3 id="jsonp-attack">JSONP attack</h3>

<p>JSONP stands for JSON with Padding, it is basically a method that developers back in the day used to send cross-origin information when CORS was not there yet. Say, we need to fetch some data from an API using JS, following snippet can do the work -</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"http://google.com/api/v1/users"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p>But the thing is that as soon as the response is fetched, it is parsed and executed by the script element. The returned response is  JSON Object, which is obviously not JS code and that’s why we get a <strong>SyntaxError</strong>. To avoid this, a function name is provided as the value of <strong>callback</strong> parameter, then the response from the service will look something like this - <strong>userSuppliedFunction(JSON Object)</strong>. The script element then parses and executes the response and that’s how we gather response without generating errors with JSONP.</p>

<p>For this attack to work, the application should allow loading resources from a website that is hosting a JSONP endpoint. Say, the target application responds with following header:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>header: Content-Security-Policy: script-src csp.com
</code></pre></div></div>

<p>A payload to trigger XSS in this scenario shall be:</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://siteHostingJsonP.com/jsonp?callback=alert('bypass')"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>

<p>Code injections attacks like XSS, Clickjacking, etc. have catastrophic impact on the application(s) and user(s) as well. Therefore, it is important to understand that CSP is not a thing to fully rely upon as it only prevents malicious scripts from getting executed, thus acting as a second line of defense.</p>

<p>You can consider following resources to dig deeper into this topic:</p>
<ul>
  <li><a href="https://blog.sucuri.net/2018/04/content-security-policy.html">Content Security Policy</a></li>
  <li><a href="https://www.imperva.com/learn/application-security/content-security-policy-csp-header/">What is Content Security Policy | Header Examples</a></li>
  <li><a href="http://conference.hitb.org/hitbsecconf2016ams/wp-content/uploads/2015/11/">CSP ODDITIES</a></li>
  <li><a href="https://research.nccgroup.com/wp-content/uploads/2020/07/csp_best_practices.pdf">CSP Best Practices</a></li>
</ul>

<p>Also, instead of manually analyzing headers, you can use tools like:</p>
<ul>
  <li><a href="https://csp-evaluator.withgoogle.com/">CSP Evaluator</a></li>
  <li><a href="https://cspvalidator.org/#url=https://cspvalidator.org/">Content Security Policy (CSP) Validator</a></li>
</ul>

<p>That’s all for this post, meet you in another one, bye.</p>]]></content><author><name></name></author><category term="Web" /><category term="csp" /><summary type="html"><![CDATA[Ah, I am writing this post after 2 years of writing my first one, procrastination never hit me like that before. Anyways, without wasting much of your time, let’s just get started with the topic. In this post, I’ll elaborate two things: How CSP works Bypassing CSP Introduction Content Security Policy is a browser security mechanism that can be used as a second line of defense against code injection attacks such as XSS, ClickJacking, etc. Content Security Policy works on whitelist based mechanism which means it maintains a list of sources from which the application is allowed to access/import resources like scripts, plugins, images, data, etc. Web Applications can impose Content Security Policy by: Issuing certain HTTP response headers X-Content-Security-Policy Content-Security-Policy X-WebKit-CSP Content-Security-Policy-Report-Only HTML Meta Tag &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'"&gt; Implementation As I said, Content Security Policy can also be implemented by issuing response header(s) and thus understanding those headers will let us see what can go wrong in certain situations and how can attackers exploit that. Content Security Policy does stuff by using directives, a directive is just a combination of resource type and attribute or it can be defined by mentioning the resource type and the attribute(s) (attributes indicate sources from where content can be loaded and/or executed of a particular resource type). If multiple directives have to be used at once, then a semicolon is used as delimiter. Following are some of the frequently used directives(with their attributes) in CSP: default-src: ‘self’ script-src: ‘unsafe-inline’ object-src: ‘none’ image-src: https: Explaination Resource Type Attribute Description default-src ‘self’ ‘default-src’ is used as a fallback option when the dev is too lazy to define sources for each resource type. ‘self’ indicates that the website can only load resource(s) from the same origin. script-src ‘unsafe-inline’ ‘script-src’ defines location from where JS code can loaded, ‘unsafe-inline’ imply that inline JS code can be loaded &amp; executed object-src ‘none’ ‘object-src’ defines sources from where plugins can be loaded, ‘none’ here clearly states that plugins are not allowed image-src https: ‘https:’ is a scheme and indicates that images should loaded from website that use “https:” You can find more directives here Exploitation Till now, we saw some examples that gave us a basic idea about how directives in CSP come along to protect the application and/or users. It’s time we should jump onto the part where analysis of directives will lead to exploration of possible vulnerablities. Developers find it complex to configure CSP and that’s what causing most of the screw ups out there. Following are some of the places where the miss outs happen, thus paving a way for code injection attacks: Using unsafe attribute(s) and/or directives Nonce JSONP attack Using unsafe attributes and/or directives So, directives are the building blocks of CSP and getting them wrong will lead to take down of the whole wall of security. In CSP, there are certains attributes that’ve already been flagged unsafe because assigning them to directives simply makes the application as vulnerable as it was without CSP. Some of these attributes and directives are: unsafe-inline unsafe-eval data: base-uri unsafe-inline - It has been flagged unsafe cause it grants the application to execute inline scripts, which basically means that any JS code injected by the attacker would be executed by the application and this defeats the whole purpose of having a CSP in the first place. unsafe-eval - There are certain functions &amp; constructors in JavaScript that are better of not being used; eval() is one of them. It can perform dynamic instructions by using input recieved from any user. Using unsafe-eval allows the application to use dynamic code evaluation which is not considered a good practice. data: - This directive is used to grant developers permission to import data from base64 strings. Using this directive in combination with script-src ‘unsafe-eval’ can lead to execution of attacker’s injected code. An exploitable situation will look something like: response header: Content-Security-Policy: script-src 'unsafe-eval' data: 'self' bypass: &lt;script src="data:;base64,WFNTCg=="&gt;&lt;/script&gt; base-uri - This directive sets the base URL for the relative URLs that exist in a document. Absence of this directive will let the attacker set/inject the base URL ultimately granting access to tamper with files that are being served on the application. &lt;head&gt; &lt;base href="http://www.google.com" target="_blank"&gt; &lt;/head&gt; &lt;script src="/hello.js"&gt;&lt;/script&gt; &lt;!-- this sets location to http://www.google.com/hello.js as the base URL is set to http://www.google.com !&gt; Nonce Nonce is just a long string of random characters. Inline scripts are by default blocked in a page by CSP, but sometimes it is a necessity to use inline script(s) and using Nonce allows developers to do so in a secure way. In order to inject an inline script, nonce attribute must be set in the script element. &lt;script nonce="r4nd0m455Ch4r5"&gt; var blah = "DND"; &lt;/script&gt; Following are some instances of misconfigs that an attacker can exploit: Same Nonce being used for multiple requests - Same Nonce can be used for multiple request, thus allowing attacker to inject inline scripts Predictable Nonce values - Values are not random, attacker can predict another valid Nonce and use that to inject inline scripts Outputting user/attacker controllable values inside Nonce protected script To understand the third bullet point, let’s consider a scenario where we’ve got an URL and a Nonce protected inline script: https://www.google.com/hey.php?id=1 &lt;script nonce="r4nd0m455Ch4r5"&gt; var id = #URL.id# //assigns the value of id parameter to this variable &lt;script&gt; id parameter in the given URL is user controllable, and to achieve code injection the attacker only needs to replace the parameter’s value with a valid payload. JSONP attack JSONP stands for JSON with Padding, it is basically a method that developers back in the day used to send cross-origin information when CORS was not there yet. Say, we need to fetch some data from an API using JS, following snippet can do the work - &lt;script src="http://google.com/api/v1/users"&gt;&lt;/script&gt; But the thing is that as soon as the response is fetched, it is parsed and executed by the script element. The returned response is JSON Object, which is obviously not JS code and that’s why we get a SyntaxError. To avoid this, a function name is provided as the value of callback parameter, then the response from the service will look something like this - userSuppliedFunction(JSON Object). The script element then parses and executes the response and that’s how we gather response without generating errors with JSONP.]]></summary></entry><entry><title type="html">Open Redirects - Everything That You Should Know</title><link href="http://localhost:4000/Open-Redirects-Everything-That-You-Should-Know/" rel="alternate" type="text/html" title="Open Redirects - Everything That You Should Know" /><published>2020-04-16T15:48:00+05:30</published><updated>2020-04-16T15:48:00+05:30</updated><id>http://localhost:4000/Open-Redirects-Everything-That-You-Should-Know</id><content type="html" xml:base="http://localhost:4000/Open-Redirects-Everything-That-You-Should-Know/"><![CDATA[<p>Hey There! In this post I’ll be explaining everything that is necessary for a layman(not really) to understand Open Redirects. Let’s start!</p>

<h3 id="introduction">Introduction</h3>

<blockquote>
  <p>Open Redirect or Open Redirection is a situation in which a website redirects or sends the user to another website by taking parameter value as the destination.</p>
</blockquote>

<p>Example:</p>
<ul>
  <li>URL : : <code class="language-plaintext highlighter-rouge">http://site.com/redir?url=http://www.google.com</code></li>
  <li>parameter name : : url</li>
  <li>parameter value : : <code class="language-plaintext highlighter-rouge">http://www.google.com</code></li>
  <li>destination(the website to which you will be redirected) : : <code class="language-plaintext highlighter-rouge">http://www.google.com</code></li>
</ul>

<h3 id="javascript-based-redirections">Javascript based redirections</h3>

<p>The URL will send you or redirect you to <code class="language-plaintext highlighter-rouge">http://www.google.com</code>. Now, let’s take a look at the code which is the cause of our redirection.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://site.com/redir?url=http://www.google.com</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">param</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">URL</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">location</span> <span class="o">=</span> <span class="nx">param</span><span class="p">.</span><span class="nx">searchParams</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">url</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>What’s happening is that, the code is taking the parameter value from the URL which is <code class="language-plaintext highlighter-rouge">http://www.google.com</code> and then it’s assigning the value to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location" target="_blank"><code class="language-plaintext highlighter-rouge">window.location</code></a> and that’s how you are getting redirected to <code class="language-plaintext highlighter-rouge">http://www.google.com</code>. And this is what we call - Javascript Based Redirection.</p>

<p><code class="language-plaintext highlighter-rouge">window.location</code> is the sink here, whereas <code class="language-plaintext highlighter-rouge">param.searchParams.get('url');</code> is the source.</p>

<p><strong>Note:</strong> When you’re trying to fuzz the parameters, remember that Javascript Based Redirections give you <code class="language-plaintext highlighter-rouge">200</code> and not <code class="language-plaintext highlighter-rouge">3xx</code> as the response code. Also, it’s usefulness is only restricted to DOM XSS.</p>

<h3 id="header-based-redirections">Header based redirections</h3>

<p>Header Based Redirections are the redirections triggered by the server side scripts written in php, java, etc. And, this redirection is the OG as it gives <code class="language-plaintext highlighter-rouge">3xx</code> as the response code and it can be uplifted to make SSRFs work.</p>

<p>Let’s see an example PHP code that does this redirection:</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$redirect_URL</span> <span class="o">=</span> <span class="nv">$_GET</span><span class="p">[</span><span class="s2">"url"</span><span class="p">];</span>
<span class="nb">header</span><span class="p">(</span><span class="s2">"Location:"</span><span class="mf">.</span><span class="nv">$redirect_URL</span><span class="p">);</span>
</code></pre></div></div>
<p>As usual, the parameter value is getting stored into the location header which leads us to our redirection. It can be chained with vulnerabilities like SSRF, OAuth token disclosure and CRLF Injection. It can also be used for phishing.</p>

<p>Functionalities you should look upto(while hunting for Open Redirects): login, signup, register &amp; logout.</p>

<h3 id="meta-refresh-redirections">Meta refresh redirections</h3>

<p>Meta Refresh Redirection is a client side redirection. It occurs within your browser and requires no server side interaction. Meta tags are inserted into the head tag.</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">content=</span><span class="s">"1;url='http://www.google.com';"</span> <span class="na">http-equiv=</span><span class="s">"refresh"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/head&gt;</span>
</code></pre></div></div>

<p>The above meta tag, if inserted in a HTML document, will redirect to <code class="language-plaintext highlighter-rouge">http://www.google.com</code> after waiting for one second. These type of redirections (Javscript Based and Meta Refresh) are client side redirections and hence they will always puke out <code class="language-plaintext highlighter-rouge">200</code> as the response code. The exploitation is just same as Javascript Based Redirection, the only thing you have to keep an eye on is the meta tag and the JS content.</p>

<p><br /></p>

<h3 id="list-of-quality-bypasses">List of quality bypasses</h3>

<p>Here’s a short list of payloads that I’ve collected, after going through some HackerOne reports and using them on different targets:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">https:www.google.com</code></li>
  <li><code class="language-plaintext highlighter-rouge">HtTp://google.com</code></li>
  <li><code class="language-plaintext highlighter-rouge">http\x3A\x2F\x2Fgoogle.com</code></li>
  <li><code class="language-plaintext highlighter-rouge">//google。com</code></li>
  <li><code class="language-plaintext highlighter-rouge">x00http://google.com</code></li>
  <li><code class="language-plaintext highlighter-rouge">////216.58.214.206</code></li>
  <li><code class="language-plaintext highlighter-rouge">/\216.58.214.206</code></li>
  <li><code class="language-plaintext highlighter-rouge">x20http://www.google.com</code></li>
  <li><code class="language-plaintext highlighter-rouge">https://www.google.com</code></li>
  <li><code class="language-plaintext highlighter-rouge">hthttp://tp://www.google.com</code></li>
  <li><code class="language-plaintext highlighter-rouge">。/www.google.com</code></li>
</ul>

<h3 id="dorks-and-parameter-names">Dorks and parameter names</h3>

<p>Some useful google dorks:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">site:target.com AND inurl:url=http(s)</code></li>
  <li><code class="language-plaintext highlighter-rouge">site:target.com AND inurl:u=http(s)</code></li>
  <li><code class="language-plaintext highlighter-rouge">site:target.com AND inurl:redirect?http(s)</code></li>
  <li><code class="language-plaintext highlighter-rouge">site:target.com AND inurl:redirect=http(s)</code></li>
  <li><code class="language-plaintext highlighter-rouge">site:target.com AND inurl:link=http(s)</code></li>
</ul>

<p>Some parameter names that need attention while looking for Open Redirects:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">?next=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?url=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?dest=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?redirect=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?returnTo=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?go=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?redirect_uri</code></li>
  <li><code class="language-plaintext highlighter-rouge">?continue=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?return_path=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?externalLink=</code></li>
  <li><code class="language-plaintext highlighter-rouge">?URL=</code></li>
</ul>

<p>More resources:</p>

<ul>
  <li><a href="https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html" target="_blank">https://pentester.land/cheatsheets/2018/11/02/open-redirect-cheatsheet.html</a></li>
  <li><a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md" target="_blank">https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.md</a></li>
  <li><a href="https://blog.detectify.com/2019/05/16/the-real-impact-of-an-open-redirect/" target="_blank">https://blog.detectify.com/2019/05/16/the-real-impact-of-an-open-redirect/</a></li>
</ul>

<p>That’s all for this post, it’s <a href="https://twitter.com/r0075h3ll">Hardik Nanda</a>, signing off!</p>]]></content><author><name></name></author><category term="Web" /><category term="open-redirect" /><summary type="html"><![CDATA[Hey There! In this post I’ll be explaining everything that is necessary for a layman(not really) to understand Open Redirects. Let’s start!]]></summary></entry></feed>